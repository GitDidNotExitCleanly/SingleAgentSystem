package uk.ac.nott.cs.g54dia.library;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;


public class Beliefs {

	private ArrayList<Point> stations;
	private ArrayList<Point> wells;
	
	private ArrayList<Point> exploringPoints;
	
	private Task task;
	
	private int fuel;
	
	private int water;
	
	private Point lastPosition;
	
	public Beliefs(int environmentSize) {
		
		// initialize stations 
		this.stations = new ArrayList<Point>();
		// initial wells
		this.wells = new ArrayList<Point>();
				
		// initialize task
		this.task = null;
		
		// initialize fuel
		this.fuel = Tanker.MAX_FUEL;
		
		// initialize water
		this.water = 0;
		
		// initialize last position
		this.lastPosition = Tanker.FUEL_PUMP_LOCATION;
		
		// calculate all points needed to explore
		this.exploringPoints = new ArrayList<Point>();
		this.generateExploreOrder(environmentSize);
	}
	
	private void generateExploreOrder(int environmentSize) {
		
		int valueSize = (environmentSize-Tanker.VIEW_RANGE)/(Tanker.VIEW_RANGE*2);
		int remaining = (environmentSize-Tanker.VIEW_RANGE)%(Tanker.VIEW_RANGE*2);
		int[] value;
		if (remaining != 0) {
			value = new int[(valueSize+1)*2+1];
		}
		else {
			value = new int[valueSize*2+1];
		}
		
		value[(value.length-1)/2] = 0;
		for (int i=1;i<value.length;i++) {
			if (i >= value.length-2 && remaining != 0) {
				if (i%2 != 0) {
					value[((value.length-1)/2)+((i+1)/2)] = value[((value.length-1)/2)+((i+1)/2)-1]+remaining;
				}
				else {
					value[((value.length-1)/2)-(i/2)] = value[((value.length-1)/2)-(i/2)+1]-remaining;
				}
			}
			else {
				if (i%2 != 0) {
					value[((value.length-1)/2)+((i+1)/2)] = ((i+1)/2)*Tanker.VIEW_RANGE*2;
				}
				else {
					value[((value.length-1)/2)-(i/2)] = -(i/2)*Tanker.VIEW_RANGE*2;
				}
			}
		}
		
		int numOfPoints = value.length*value.length;
		int lastXIndex = (value.length-1)/2;
		int lastYIndex = (value.length-1)/2;
		int lastDir = 0;
		int[] lastLength = {0,0};
		int count = 0;
		while (count < numOfPoints-1) {
			if (lastLength[0] == lastLength[1]) {
				lastLength[0] = lastLength[1];
				lastLength[1]++;
			}
			else {
				lastLength[0] = lastLength[1];
			}
			for (int i=0; i < lastLength[1] && count < numOfPoints;i++) {
				switch (lastDir) {
				case 0:
					lastYIndex++;
					break;
				case 1:
					lastXIndex--;
					break;
				case 2:
					lastYIndex--;
					break;
				case 3:
					lastXIndex++;
					break;
				}
				this.exploringPoints.add(new Point(value[lastXIndex],value[lastYIndex]));
				count++;
				if (count >= numOfPoints-1) {
					break;
				}
			}
			lastDir = (lastDir+1)%4 ;
		}
	}
	
	
	// functions for field ArrayList series
	
	
	
	
	// functions for field 'TASK'
	public boolean isThereTask() {
		if (this.task != null) {
			return true;
		}
		else {
			return false;
		}
	}
	
	public Task getTask() {
		return this.task;
	}
	
	
	
	// functions for field 'FUEL'
	public boolean isFuelEnoughForReturn(Point point) {
		int dx = point.x - Tanker.FUEL_PUMP_LOCATION.x;
		int dy = point.y - Tanker.FUEL_PUMP_LOCATION.y;
		
		if (this.fuel >= Math.max(dx, dy)) {
			return true;
		}
		else {
			return false;
		}
	}
	
	public int getFuel() {
		return this.fuel;
	}
	
	
	// functions for field 'LASTPOSITION'
	public Point getLastPosition() {
		return this.lastPosition;
	}
	
	
	private final static int
	    NORTH       =   0,
	    SOUTH       =   1,
	    EAST        =   2,
	    WEST        =   3,
	    NORTHEAST   =   4,
	    NORTHWEST   =   5,
	    SOUTHEAST   =   6,
	    SOUTHWEST   =   7,
		STILL		= 	8;
	// update beliefs
	public void updateBeliefs(Cell[][] view,int fuel,int water, Point currentPosition) {
		int direction;
		int dx = currentPosition.x - this.lastPosition.x;
		int dy = currentPosition.y - this.lastPosition.y;
		if (dx == 0 && dy == 0) {
			direction = this.STILL;
		}
		else if ( dx == 0 & dy < 0) {
			direction = this.SOUTH;
		}
		else if ( dx == 0 && dy > 0) {
			direction = this.NORTH;
		}
		else if ( dx > 0 && dy > 0) {
			direction = this.NORTHEAST;
		}
		else if ( dx > 0 && dy == 0 ) {
			direction = this.EAST;
		}
		else if ( dx > 0 && dy < 0) {
			direction = this.SOUTHEAST;
		}
		else if ( dx < 0 && dy > 0 ) {
			direction = this.NORTHWEST;
		}
		else if ( dx < 0 && dy == 0) {
			direction = this.WEST;
		}
		else {
			direction = this.SOUTHWEST;
		}
		
		int m;
		int n;
		switch (direction) {
			case STILL:
				for (int i=0;i<view.length;i++) {
					for (int j=0;j<view[i].length;j++) {
						
						// is this cell a well ?
						if (view[i][j] instanceof Well) {
							this.wells.add(view[i][j].getPoint());
						}						
						// is this cell a station ? if so, is there any task ?
						else if (view[i][j] instanceof Station) {
							if (((Station)view[i][j]).getTask() != null) {
								this.task = ((Station)view[i][j]).getTask();
							}
						}
					}
				}
				break;
			case SOUTH:
				m = view.length-1;
				for (int j=0;j<view[m].length;j++) {
	
					// is this cell a well ?
					if (view[m][j] instanceof Well) {
						this.wells.add(view[m][j].getPoint());
					}						
					// is this cell a station ? if so, is there any task ?
					else if (view[m][j] instanceof Station) {
						if (((Station)view[m][j]).getTask() != null) {
							this.task = ((Station)view[m][j]).getTask();
						}
					}
				}
				break;
			case NORTH:
				m = 0;
				for (int j=0;j<view[m].length;j++) {
					
					// is this cell a well ?
					if (view[m][j] instanceof Well) {
						this.wells.add(view[m][j].getPoint());
					}						
					// is this cell a station ? if so, is there any task ?
					else if (view[m][j] instanceof Station) {
						if (((Station)view[m][j]).getTask() != null) {
							this.task = ((Station)view[m][j]).getTask();
						}
					}
				}
				break;
			case NORTHEAST:
				
				break;
			case EAST:
				break;
			case SOUTHEAST:
				break;
			case NORTHWEST:
				break;
			case WEST:
				break;
			case SOUTHWEST:
				break;
		}
		
		// is current cell a exploring point ?
		
		
		// update fuel
		this.fuel = fuel;
		
		// update water
		this.water = water;
		
		// update last position
		this.lastPosition = currentPosition;
		
	}
	
}
