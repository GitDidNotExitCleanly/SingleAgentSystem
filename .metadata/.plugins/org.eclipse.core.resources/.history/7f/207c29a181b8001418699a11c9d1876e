import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;


public class Beliefs {

	//private ArrayList<Point> stations;
	//private ArrayList<Point> wells;
	
	//private Task task;
	
	//private int fuel;
	
	private Queue<Point> exploringOrder;
	
	public Beliefs(int environmentSize) {
		
		// initialize stations 
	//	this.stations = new ArrayList<Point>();
		// initial wells
	//	this.wells = new ArrayList<Point>();
				
		// initialize task
	//	this.task = null;
		
		// initialize fuel
	//	this.fuel = Tanker.MAX_FUEL;
		
		// calculate all points needed to explore
		this.exploringOrder = new LinkedList<Point>();
		this.generateExploreOrder(environmentSize);
	}
	
	private void generateExploreOrder(int environmentSize) {
		
		int valueSize = (45-12)/(12*2);
		int remaining = (45-12)%(12*2);
		int[] value;
		if (remaining != 0) {
			value = new int[(valueSize+1)*2+1];
		}
		else {
			value = new int[valueSize*2+1];
		}
		
		value[(value.length-1)/2] = 0;
		for (int i=1;i<value.length;i++) {
			if (i >= value.length-2 && remaining != 0) {
				if (i%2 != 0) {
					value[((value.length-1)/2)+((i+1)/2)] = value[((value.length-1)/2)+((i+1)/2)-1]+remaining;
				}
				else {
					value[((value.length-1)/2)-(i/2)] = value[((value.length-1)/2)-(i/2)+1]-remaining;
				}
			}
			else {
				if (i%2 != 0) {
					value[((value.length-1)/2)+((i+1)/2)] = ((i+1)/2)*12*2;
				}
				else {
					value[((value.length-1)/2)-(i/2)] = -(i/2)*12*2;
				}
			}
		}
		
		int numOfPoints = value.length*value.length;
		this.exploringOrder.offer(new Point(0,0));
		int lastXIndex = (value.length-1)/2;
		int lastYIndex = (value.length-1)/2;
		int lastDir = 0;
		int[] lastLength = {0,0};
		int count = 0;
		while (count < numOfPoints) {
			if (lastLength[0] == lastLength[1]) {
				lastLength[0] = lastLength[1];
				lastLength[1]++;
			}
			else {
				lastLength[0] = lastLength[1];
			}
			for (int i=0;i<lastLength[1];i++) {
				switch (lastDir) {
				case 0:
					lastYIndex++;
					break;
				case 1:
					lastXIndex--;
					break;
				case 2:
					lastYIndex--;
					break;
				case 3:
					lastXIndex++;
					break;
				}
				this.exploringOrder.offer(new Point(value[lastXIndex],value[lastYIndex]));
				count++;
			}
			lastDir = (lastDir+1)%4 ;
		}
	}
	
	// functions for field 'MAP'
	
	
}